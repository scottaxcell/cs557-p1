How to build:
=============
$ make all


How to run:
===========
$ ./proj1


Reused code:
============
The only code I largely borrowed directly is from the test-app-c.c example
provided in the timers library. Specifically, the while loop logic for creating
and firing off timers. A change I made to this code was to remove the logic
that terminated the while loop if no timers existed. This behavior was not
desired in my design.

Besides the timers library I referenced varies websites for snippets of
code for things I did not know how to accomplish in C. See the References 
section below for a list of the sites I referenced.


Message format:
===============
* I added the pktsize to hte beginnin of every message so that the receiver 
knows how much of the data to read. This way it is getting the full message.

GROUP_SHOW_INTEREST (client -> tracker): client notifies tracker of files it is interested in
  Fields: pktsize, msgtype, client id, number of files, filename, file size, type, ...
  * I added the file size so that downloading clients could know how large a file
  was that they were interested in downloading.


GROUP_ASSIGN (tracker -> client): tracker notifies client about other client meta data
  Fields: pktsize, msgtype, number files, filename, file size, num neighbors, neigh. id, neigh. ip, neigh port, ...
  * I added the file size so that downloading clients could know how large a file
  was that they were interested in downloading.


CLNT_INFO_REQ (client -> client): client queries client for segment information for a file
  Fields: pktsize, msgtype, client id, filename


CLNT_INFO_REP (client -> client): client notifies client of file segments it has to offer for a file
  Fields: pktsize, msgtype, client id, filename, num segments, segment number, ...


CLNT_SEG_REQ (client -> client): client queries client for a specific segment for a file
  Fields: pktsize, msgtype, client id, filename, segment number


CLNT_SEG_REP (client -> client): client sends a raw segment of a file to a client
  Fields: pktsize, msgtype, client id, filename, segment, size of segment, raw file data
  * I send the segment size because it may be less than 32 bytes since it
  may be the last (segment) portion of a file.


Idiosyncrasies:
===============
This program only supports sharing of files 320kB or less. This is due to the fact
I chose a hard code value of 10240 maximum segments for a file. I'd like to change
this implementation to use a dynamic malloc so that the program can supprt any
size file in the future.

Phase 1: Program correctly creates a process for the tracker and clients. All
configuration information is sent from the manager to them successfully.

Phase 2: A single client correctly downloads a file from another client. The
downloaded file appears to be corrupted and I'm not sure why. I have used this
method (using unsigned chars) of sending files over the network before and
 have not had issue. Unfortunately, I did not have time to resolve this.

Phase 3: A number of clients correctly download a single file from each other. Again
the files are corrupted, but the sizes are correct.

Phase 4: I have not managed to get this working at this point.

Phase 5: I did not implement the packet loss portion of the project for extra credit.


Protocol corner cases:
======================
1. One to one transfer:
If the sharing client starts significantly earlier than the downloading client
there is the possibility it may terminate before ever receiving requests
from the downloading client.

2. Many to many transfer:
If many clients are attempting to download and only a single client shares
then there is concern that downloads will quite a bit of time. Since a single
client is servicing the rest of the clients there is potential for the sharing
client's buffers to become congested and start dropping tails. Since we're using
a UDP protocol, this will just extend the time that it takes to download a file.
This phenomenon where clients download a file and do not do their due diligence
to share it with others is called leeching.

3. Transfer with multiple files:
Clients downloading multiple files must be sure to track which file the 
received segment belongs too. Otherwise there is potential for writing the
wrong segments to the wrong files.

4. Transfer with loss:
If there is a substantial amount of loss then it can clients to terminate early.
This will also extend the length of time it takes to download a file.


Termination method:
===================
I chose to use the suggested termination algorithms provided. I tested a number of 
different scenarios and termination algorithms and I found the suggested 
algorithms to be most natural. I chose to keep the manager alive while the 
child processes (clients and tracker) were alive. This helps prevent zombie processes
on a machine.

Manager: Waits for all child processes to exit before exiting.

Client: If downloading tasks are complete and there is no request from other clients
for 2 rounds of group update, it terminates. It terminates if it is unable to
make progress on downloading after 4 rounds of group update too.

Tracker: If there are no requests from clients for 30 seconds it terminates.


Surprises:
==========
In hindsight I should have stuck with a C/C++ implementation. I began with a
C/C++ implementation, but chose to rewrite the project in the early phase as
C only. I thought having only C datastructures would make the code easier to
manage. This turned out to be the wrong way to go. I miss judged how large and
complicated this project was. C++ would have a been a more solid solution as
it provides really nice containers and features. C++11 provides a really
nice API in the standard that allows the developer to not have to 
fuss with some of the nitty gritty details that need to be addressed in C.
For example, the vector datastructure would allow me to not have to have a 
separate variable for every container keeping track of how many elements are
actually used. This was a very interesting project so I think I will 
rewrite it using C++ for my own enjoyment and so that I can get everything
working fully.

Additionally, I was surprised that serilization needed to be done to
numbers in messages even though all the messages were being sent back
and forth to ports on the same machine. I was under the impression
serializatio was done to rectify big endian differences on different
machines, but that doesn't seem to be the only reason.


References:
===========
Using TCP/UDP sockets - good explanations of functions used
http://beej.us/guide/bgnet/

Another client and server exmaple
http://www.tutorialspoint.com/unix_sockets/socket_server_example.htm

Example using UDP sockets
http://www.binarytides.com/programming-udp-sockets-c-linux/

Writing data out as a hex string
http://stackoverflow.com/questions/11992677/printf-raw-data-to-a-fixed-length-hex-output

De/serializing data for tranfer over a network
htttp://stackoverflow.com/questions/1653681/serialization-deserialization-of-a-struct-to-a-char-in-c

Select example
http://www.gnu.org/software/libc/manual/html_node/Server-Example.html

Writing and reading a file
http://stackoverflow.com/questions/22129349/reading-binary-file-to-unsigned-char-array-and-write-it-to-another

